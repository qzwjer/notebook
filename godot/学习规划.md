### 自上而下学习

1. 确定要实现的效果
2. 搜索实现效果的可用方案
3. 确定方案
4. 确定技术细节
5. 确定实现步骤
6. 开始实现
7. 遇到困难
8. 解决方案


### 基本教程
教程链接<https://www.bilibili.com/video/BV14Y411h7Po>
特效教程<https://www.bilibili.com/video/BV1K84y177Xy>

==读到了24节==

1. 创建场景
2. 显示角色，移动
3. 音频播放
4. 动画播放

### 实现效果
1. [x] 鼠标特效，外观：鼠标资源大小不能超过256*256像素
2. [x] 表情选择，动画：准备表情和表情框
3. [x] 文字显示特效，逐字：使用timer，配合富文本能更好的显示
4. [x] 文本框适应文字长度：使用ninepatchrect与label或richtextlabel结合
5. [x] 文本框样式，外观，跟随角色：使用ninepatchrect，添加texture，设置region rect、patch margin
6. [ ] ~~天赋抽取，齿轮，音效~~ 暂时不做
7. [x] 场景切换，切换动画效果：先切换到动画场景播放动画，动画播放完毕后，切换到下个场景
8. [x] 碰撞检测及反馈：rigidbody2d需要设置max_contacts_reported 和 contact_monitor 才能触发 body_entered等信号
9. [x] 射击弹幕检测击中目标：设置子弹为physicsbody2d，设置物体能触发碰撞信号，检测触发体在bullet组后，销毁子弹，物体减血量等
10. [x] 火焰粒子特效
11. [ ] 场景切换动画制作：淡入、淡出、切片、浮现、波纹：比较繁杂，需要根据具体效果选择实现方法
12. [ ] 角色移动动画制作
13. [ ] tilemap制作地图
14. [ ] 添加中文字体
15. [ ] 添加光照
16. [x] 冲刺：在检测到wasd的同时检测是否按下shift键，改变速度，同时激活粒子系统发射残影
17. [ ] 相机跟随
18. [ ] 屏幕抖动
19. [x] 实现场景控制：需要固定每个场景的大小

### 开发问题
1. [ ] 对话树系统如何设计，剧情
2. [ ] UI richtextlabel能不能设置背景色，如何设置


### 代码实现
#### 鼠标
```gdscript
var arrow = load("res://arrow.png")

func _ready():
    Input.set_custom_mouse_cursor(arrow)

func _unhandled_input(event):  
	if event is InputEventMouseButton:  
		if event.pressed:  
			if event.button_index == BUTTON_LEFT:  
				print("鼠标左键被点击了，位置：", event.position)

func _process(delta):
    print(get_global_mouse_position())
```

#### 绘制图形
```gdscript
# 调用update()来重新绘制
func _draw():
    draw_rect(....)
```

#### 获取窗口大小
`get_viewport_rect().size`


#### 全局脚本
定义`global.gd`，然后配置成单例（项目设置->自动加载）
查看文档[Singletons](https://docs.godotengine.org/zh-cn/4.x/tutorials/scripting/singletons_autoload.html)
```gdscript
extends Node

var current_scene = null

signal complete

func _ready():
	var root = get_tree().root
    current_scene = root.get_child(root.get_child_count() - 1)

func goto_scene(path):
    # This function will usually be called from a signal callback,
    # or some other function in the current scene.
    # Deleting the current scene at this point is
    # a bad idea, because it may still be executing code.
    # This will result in a crash or unexpected behavior.

    # The solution is to defer the load to a later time, when
    # we can be sure that no code from the current scene is running:

    call_deferred("_deferred_goto_scene", path)


func _deferred_goto_scene(path):
    # It is now safe to remove the current scene
    current_scene.free()

    # Load the new scene.
    var s = ResourceLoader.load(path)

    # Instance the new scene.
    current_scene = s.instantiate()

    # Add it to the active scene, as child of root.
    get_tree().root.add_child(current_scene)

    # Optionally, to make it compatible with the SceneTree.change_scene_to_file() API.
    get_tree().current_scene = current_scene
```
```gdscript
# Add to 'Scene1.gd'.

func _on_button_pressed():
    global.goto_scene("res://scene_2.tscn")
```
```gdscript
# Add to 'Scene2.gd'.

func _on_button_pressed():
    global.goto_scene("res://scene_1.tscn")
```